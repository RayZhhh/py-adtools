# Welcome to Py-ADTools

**Py-ADTools** is a powerful Python toolkit for LLM-aided algorithm design and code optimization. It provides a suite of tools for robust code parsing, secure sandboxed execution, and extensible evaluation.

This library is designed for researchers and developers working on automated programming, genetic algorithms, and evaluating code generated by Large Language Models.

## Key Features

- **Structured Code Parsing**: Decompose Python code into manipulatable AST-based objects. Modify functions, classes, and docstrings programmatically.
- **Secure Execution**: Run untrusted code in an isolated environment using either `multiprocessing` or `Ray` as a backend. Protect against infinite loops, resource exhaustion, and malicious code.
- **Extensible Evaluation**: Build custom evaluators to test code for correctness, performance, or any other metric. The framework handles the sandboxing, so you can focus on the evaluation logic.
- **Unified Language Model Interface**: Interact with various LLM backends like OpenAI, vLLM, and SGLang through a consistent API.
- **HTTP Evaluation Server**: Deploy your evaluator as a web service to create a decoupled, scalable evaluation pipeline.

## Getting Started

To get started, check out the **[Installation](./installation.md)** guide and then walk through the **Quick Start** example below.

### Quick Start: Evaluate a Sorting Algorithm

This example shows how to use `PyEvaluator` to test an LLM-generated merge sort algorithm.

#### 1. Define an Evaluator

Create a class that inherits from `PyEvaluator` and implements the `evaluate_program` method.

```python
import time
from typing import Dict, Callable, Any
from adtools.evaluator import PyEvaluator

class SortAlgorithmEvaluator(PyEvaluator):
    def evaluate_program(
        self,
        callable_functions_dict: Dict[str, Callable],
        **kwargs,
    ) -> Any | None:
        sort_algo = callable_functions_dict.get("merge_sort")
        if not sort_algo:
            return None 

        input_data = [10, 2, 4, 76, 19, 29, 3, 5, 1]
        
        start = time.time()
        res = sort_algo(input_data)
        duration = time.time() - start
        
        if res == sorted(input_data):
            return duration
        else:
            return None
```

#### 2. Evaluate Code Securely

Instantiate your evaluator and use the `secure_evaluate` method to run code in a sandbox.

```python
code_from_llm = """
def merge_sort(arr):
    if len(arr) <= 1: return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    # ... (merge logic)
    def merge(left, right):
        result = []
        i = j = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]: result.append(left[i]); i += 1
            else: result.append(right[j]); j += 1
        result.extend(left[i:]); result.extend(right[j:])
        return result
    return merge(left, right)
"""

evaluator = SortAlgorithmEvaluator()
results = evaluator.secure_evaluate(code_from_llm, timeout_seconds=10)

print(f"Score (Execution Time): {results['result']:.4f}s")
```

Dive into the documentation sections to learn more about each component.
